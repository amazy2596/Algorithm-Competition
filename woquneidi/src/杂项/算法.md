# 出现的错误检查

1. 超出范围(int, i64)
2. 取模出现错误
3. 图可能有重边或者自环

# 杂项 (通用)

想不到的题考虑: 

1. 二分, 二分答案, 三分
2. dp
3. 离线
4. 倒推
5. 倍增
6. 建图

分块

势能分析

矩阵加速

一个二进制状态, 枚举他的所有子集状态  for(j = status; j > 0; j = (j - 1) & status);

中位数: 

- 变成二分 变成+1 -1判断
-  若动态维护, 每次加入一个数 然后求中位数, 用对顶堆
-  如果还有删除一个数, 那么就用对顶multiset

# dp

- 背包

- 区间dp

- DAG图上的dp

- 树形dp

  - 直接dfs

  - DFN序: 

    - 能够知道这个节点的子树大小

    - 某节点在不在此子树
    - 适用于对于一个节点向一个还没有合并过的节点合并复杂度较低的问题

  - 换根dp

  - 基环树: 

- 状压dp

- 数位dp

# 搜索

- dfs, bfs
- bfs不适用于有权图 01bfs可适用于权值只有0和1的图
- 双向广搜 : 两边各搜一半再合并

# 图论

- 拓扑排序: 
  - 能够处理环, 算出环的大小, 链的大小等
- tarjan缩点(连通性相关)
  - 边双联通分量: 等价于:该子图中任意两点之间至少存在两条边互不相交的路径
  - 点双联通分量: 等价于:任意两点之间至少存在两条内部点互不相交的路径。

# 树

- 倍增

  - lca

- 树的重心

  - 定义:
    1. 以某个节点为根时，最大子树的节点数最少，那么这个节点是重心
    2. 以某个节点为根时，每颗子树的节点数不超过总节点数的一半，那么这个节点是重心
    3. 以某个节点为根时，所有节点都走向该节点的总边数最少，那么这个节点是重心
  - 性质:
    1. 一棵树最多有两个重心，如果有两个重心，那么两个重心一定相邻
    2. 如果树上增加或者删除一个叶节点，转移后的重心最多移动一条边
    3. 如果把两棵树连起来，那么新树的重心一定在原来两棵树重心的路径上
    4. 树上的边权如果都为正数，不管边权怎么分布，所有节点都走向重心的总距离和最小

- 树的直径

  - 求法: 

    1. 两次dfs 找两个距离最远的点 不适用于有负边的树
    2. 树形dp 对于每个点找子树中的最长的两条链 适用于所有树

  - 性质:

    如果树上的边权都为正，则有如下直径相关的结论：

    1. 如果有多条直径，那么这些直径一定拥有共同的中间部分，可能是一个公共点或一段公共路径
    2. 树上任意一点，相隔最远的点的集合，直径的两端点至少有一个在其中

- 树上差分

  - 点差分
  - 边差分

- 换根dp

- 重链剖分

- 树上启发式合并

  - 适用于对多个子树统计答案

  - 树上启发式合并的特征：

    1，没有修改操作

    2，可以通过遍历子树，建立信息统计，得到所有查询的答案

# 数学

### 数论

- 费马小定理
- 欧拉定理 扩展欧拉定理
- 威尔逊定理
- 中国剩余定理

- 欧拉函数

- 莫比乌斯函数




### 组合数学

- 组合数
  - 卢卡斯定理
- 隔板法
  - n个相同元素, 分为k组
- 容斥原理
- 卡特兰数
  - 四个公式
    1. $f(n) = C(2n, n) - C(2n, n - 1)$
    2. $f(n) = C(2n, n) / (n + 1)$
    3. $f(n) = f(n - 1) * (4n - 2) / (n + 1)$
    4. $f(n) = \sum_0^{n - 1}f(i) * f(n - i - 1)$
  - 模型
    1. 进出栈模型
    2. 路径计数模型
    3. 划分左右相乘模型

## &nbsp;

- 互质的情况
- 素数密度
- 质数判断: 
  1. 一个较小质数判断, 试除法 
  2. 一个较大质数判断, miller rabin
  3. 一个范围内质数(较多质数)判断 欧拉筛
  4. 要筛的区间较大时: 二次筛法
- 质因数分解:
  1. 数量少用试除法 O(sqrt(n))
  2. 数量多欧拉筛 除以minp
- 矩阵快速幂
- 整除分块
- 线性基
  - 每个基底选或不选, 可以凑出来原数组可以凑出来的所有非零异或和 还能知道第k小的异或和
- 卢卡斯定理 $C_{n}^{m} \equiv C_{n / p}^{m/p} * C_{n \% p}^{m \% p}(\%p) $  $p$ 为质数

### 生成函数

- 普通生成函数

  普通生成函数: $F(n) = \sum_{i >= 0} a_{i}x^{i}$

  乘法运算:  $F(x)G(x) = \sum_{i >= 0}a_{i}x^{i}\sum_{j >= 0} b_{j} x_{j} = \sum _{n>=0}x^{n}\sum_{i = 0}^{n} a_{i}b_{n-i}$

  普通生成函数用于解决多重集组合数问题: n种物品, 每种有个,问取m个物品的组合数

  答案即为$(1 + x^{1} + x^{2} + ... + x^{a_{1}})(1 + x^{1} + x^{2} + ... + x^{a_{2}})...(1 + x^{1} + x^{2} + ... + x^{a_{n}})$, $x_{m}$的系数

- 指数生成函数

  $F(n) = \sum_{i >= 0} a_{i}\frac{x^{i}}{i!}$
  乘法运算: $F(x)G(x) = \sum_{i >= 0}a_{i}\frac{x^{i}}{i!}\sum_{j >= 0}a_{j}\frac{x^{j}}{j!} = \sum _{n>=0} \frac{x^{n}}{n!} \sum_{i = 0}^{n}C_{n}^{i} a_{i}b_{n-i}$

  指数生成函数用于解决多重集排列数问题: n种物品, 每种有个,问取m个物品的排列数

  假设第$i$种物品选$b_{i}$个, 则答案为$\frac{m}{b_{1}!b_{2}!...b_{n}!}$ 
  即为$(1 + \frac{x^{1}}{1!} + \frac{x^{2}}{2!} + ... + \frac{x^{a_{1}}}{a_{1}!})(1 + \frac{x^{1}}{1!} + \frac{x^{2}}{2!} + ... + \frac{x^{a_{2}}}{a_{2}!})...(1 + \frac{x^{1}}{1!} + \frac{x^{2}}{2!} + ... + \frac{x^{a_{n}}}{a_{n}!})$答案即为$\frac{x^{m}}{m!}$的系数


# 字符串

- kmp
- 字符串哈希
- trie

# 数据结构

- 链表, 栈, 队列
- 单调栈: 能够知道每个数前面距离最近的比它大或者小的数
- 单调队列: 能够知道每个长度为k的子区间的最值
- 堆
  - 对顶堆: 能够方便的动态维护集合中第k大的元素
- 并查集: 
  - 扩展域/种类并查集 : 能够维护满足1.朋友的朋友是朋友 2.敌人的敌人是朋友
  - 带权并查集: 维护到根的距离并且取模能够达到类似扩展域并查集的效果
- 线段树: 
  - 区间加减
  - 区间修改 Tag设一个ip变量代表是否修改
  - 势能分析  直接暴力修改到叶子
  - 区间合并
  - 扫描线的修改, 区间懒标记是否被选取, 因为删除的时候 只会删除已经添加过的区间
  - 动态开点
- 树状数组
  - 能够维护可差分信息
  - 能够更快的边维护边查单个点的前缀
  - 能够动态地知道每个数前面有多少个小于它的数
  - kth知道第k大的数是多少
  - 树上二分
- 波纹疾走树
  - 查询区间第k小的数字
  - 区间内一个数字/一段数字的频率

